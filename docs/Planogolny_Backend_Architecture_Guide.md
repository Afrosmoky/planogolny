# Planogolny.info â€” Backend Architecture & Implementation Guide

## 1. Purpose of This Document

This document explains **what has been built so far**, **why the architecture looks the way it does**,  
and **how all modules, patterns, and flows work together**.

It is meant to help you:
- fully understand the backend structure,
- confidently continue implementation,
- know **what to learn next** and **what keywords to search for**,
- smoothly continue work in a new chat.

---

## 2. High-Level Architecture Overview

The project uses a **Modular Monolith** architecture inside **Laravel 12**.

```
/app                â†’ Framework & delivery layer (controllers, Inertia)
/packages           â†’ Domain modules (business logic)
```

Key rule:
> **All business logic lives in `packages/`.  
Controllers only orchestrate actions.**

---

## 3. Core Architectural Principles

### 3.1 Modular Monolith
- One codebase
- Strong module boundaries
- No shared domain logic between modules
- Easy to refactor into microservices later (if ever needed)

### 3.2 Clean Architecture (Lightweight)
- DTOs isolate data
- Actions represent use cases
- Services contain reusable logic
- Models exist only where state must be persisted

### 3.3 No Overengineering
- No full Event-Driven Design
- No sagas
- No CQRS
- Only **2â€“3 lightweight events**

---

## 4. Design Patterns Used (Explicitly)

### 4.1 Action / Command Pattern
Used everywhere for use cases.

Examples:
- CreatePaymentSessionAction
- RunAnalysisAction
- CreateInvoiceAction
- GenerateReportAction

Why:
- single responsibility
- easy testing
- clean controller code

---

### 4.2 DTO Pattern (Immutable)
All DTOs are `final readonly`.

Why:
- immutability
- predictable data flow
- no accidental mutation
- clear contracts between layers

---

### 4.3 Strategy Pattern (Payments)
```
PaymentGatewayInterface
â”œâ”€â”€ StripeGateway
â””â”€â”€ TpayGateway
```

Why:
- easy gateway replacement
- no conditionals in business logic
- IoC container acts as strategy resolver

---

### 4.4 Facade Pattern (GIS & Invoicing)
```
GisFacade
IngInvoiceApi
```

Why:
- hide external API complexity
- provide a single entry point
- easy mocking and caching later

---

### 4.5 Observer Pattern (Lightweight Events)
Used only where modules must react to state changes.

Examples:
- OrderPaid
- InvoiceCreated
- ReportGenerated

This is **NOT** full EDD â€” just Laravel Events as observers.

---

## 5. Module Responsibilities (Summary)

### 5.1 GIS
- Fetches parcel and surrounding data
- Talks to OSM, Geoportal, Google
- Returns normalized DTOs
- Uses Facade pattern

All external GIS providers are executed in parallel.
The facade is responsible for timeouts, partial failures and result normalization.
Analysis never depends on synchronous availability of all providers.

---

### 5.2 Analysis
- Pure computation
- No external calls
- Calculates scores and probabilities
- Outputs normalized results (0â€“100%)

---

### 5.3 Payments
- Creates payment sessions
- Verifies payments (webhooks)
- Uses Strategy pattern
- Emits payment completion signals

---

### 5.4 Orders
- Stores order state
- Is the **source of truth**
- Emits OrderPaid event
- Does NOT know who listens

---

### 5.5 Invoicing
- Listens to OrderPaid
- Creates invoice in ING
- Downloads invoice PDF
- Forwards invoice to Reporting

Important:
> Invoice numbers are generated by ING, not the app.

---

### 5.6 Reporting
- Generates final PDF report
- Attaches invoice
- Sends email
- Marks order as completed

---

## 6. End-to-End Flow (Happy Path)

```
User pays
   â†“
Payments verifies payment
   â†“
Orders marks order as paid
   â†“
OrderPaid event
   â†“
Invoicing listener
   â†’ create invoice
   â†’ download invoice
   â†“
Reporting
   â†’ generate report
   â†’ send email
```

Each step is isolated, testable, and replaceable.

---

## 7. Why Events Are Minimal (Important)

Events are used only when:
- one module should not know another exists
- reaction happens after a state change

Events are NOT used for:
- core logic
- orchestration
- complex workflows

This keeps the system understandable and debuggable.

---

## 8. How to Reason About This Codebase

Ask these questions:
1. **Which module owns this responsibility?**
2. **Is this a use case? â†’ Action**
3. **Is this data transfer? â†’ DTO**
4. **Is this integration? â†’ Service / Facade**
5. **Is this a reaction to state? â†’ Event + Listener**

If you follow this consistently, the architecture stays clean.

---

## 9. Learning & Research â€” What to Google

### Architecture & Patterns
- "Laravel modular monolith architecture"
- "Clean architecture Laravel actions DTO"
- "Command pattern PHP application service"
- "Facade pattern API integration PHP"
- "Strategy pattern payment gateway PHP"

### Events & Observers
- "Laravel events listeners explained"
- "Observer pattern Laravel example"
- "When not to use event driven architecture"

### PDF & Reporting
- "Laravel PDF generation wkhtmltopdf"
- "Laravel Browsershot PDF"
- "HTML to PDF report generation best practices"

### GIS & Analysis
- "OSM Overpass API tutorial"
- "GIS spatial analysis PHP"
- "Distance calculation geospatial PHP"

---

## 10. Recommended Next Steps (New Chat)

### Step 1 (Best Start)
ðŸ‘‰ Implement **one full vertical slice**:

**Payments â†’ Orders**

- payment webhook
- verify payment
- create order
- emit OrderPaid

This builds confidence and validates architecture.

---

### Step 2
Implement **Invoicing integration** (API calls + PDF fetch).

---

### Step 3
Implement **Analysis scoring logic** (core business value).

---

### Step 4
Build **PDF layout and report template**.

---

## 11. Final Note

This backend is:
- clean
- understandable
- scalable
- portfolio-grade
- NOT overengineered

Most importantly:
> **You can reason about every line of code.**

That is the biggest success of this architecture.

---

**Ready to continue in a new chat.**
